# -*- coding: utf-8 -*-
"""
Created on Sun Feb  8 11:36:23 2015

@author: ryanterrill
"""

# Create a tuple that contains the names of the chain's states

States=("A","B")

# Define a transition probability matrix for the chain with states A and B

Matrix=[[0.4,0.6],[0.7,0.3]]

# Try accessing a individual element or an individual row 
# Element

Matrix[0][1]

# Row
Matrix[1]


# Import scipy U(0,1) random number generator

import scipy

# Paste or import your discrete sampling function

rand=scipy.random.random()

# Write your Markov chain simulator below. Record the states of your chain in 
# a list. Draw a random state to initiate the chain.



def markovChain(matrix,length):
    chain=[]
    seed=scipy.random.random(1)
    states=("A","B")
    if seed<matrix[0][0]:
        state=states[0]
    else: 
        state=states[1]
    chain.append(state)
    if length ==1:
        return chain
    else:
        for state in markovChain(matrix,(length-1)):
            if state=="A":
                seed=scipy.random.random(1)
                if seed<=matrix[0][0]:
                    state=="A"
                else:
                    state=="B"
            elif state=="B":
                seed=scipy.random.random(1)
                if seed<=matrix[1][1]:
                    state=="B"
                else:
                    state=="A"
            chain.append(state)     
        return chain
   
                
        
    





# Run a simulation of 10 steps and print the output.

mc=markovChain(Matrix,10)

print mc



# Now try running 100 simulations of 100 steps each. How often does the chain
# end in each state? How does this change as you change the transition matrix?

def multiMC(chains,matrix,length):
    chainMatrix=[]
    if chains==1:
        chainMatrix=markovChain(matrix,length)
    else:    
        while chains>0:
            ch=markovChain(matrix,length)
            chainMatrix.append(ch)
            chains=chains-1
    return chainMatrix       
    

chainMatrix=multiMC(100,Matrix,100)


ch=chainMatrix[0][0]
ch.count("A")
def counter(matrix,state):
    out=0
    for i in range(100):
         for j in range(100):
            ch=matrix[i][j]
            statecount=ch.count(state)
            out=out+statecount
    return out
    
def printstates(chain,matrix):
    print " A = "+str(counter(chain,"A"))+"  B = "+str(counter(chain,"B"))+"  matrix = "+str(matrix) 

printstates(chainMatrix,Matrix)

Matrix1=[[0.1,0.9],[0.9,0.1]]

chainMatrix1=multiMC(100,Matrix1,100)
printstates(chainMatrix1,Matrix1)

Matrix2=[[1,0],[1,0]]

chainMatrix2=multiMC(100,Matrix2,100)
printstates(chainMatrix2,Matrix2)



# Try defining a state space for nucleotides: A, C, G, and T. Now define a 
# transition matrix with equal probabilities of change between states.

nucs=["A","C","G","T"]
nucMatrix=[[0.25,0.25,0.25,0.25],[0.25,0.25,0.25,0.25],[0.25,0.25,0.25,0.25],[0.25,0.25,0.25,0.25]]

nucTrans=[[a+b,a+b,a+b,a+b] for a in nucs for b in nucs]    

def nucLine(row,nucs):
    nucLine=[]
    for i in range(4):
        row=row
        g=nucs[row]
        f=nucs[i]
        nucLine.append((g,f))
    return nucLine   
    
def nucMatrix(nucs):
    nucMatrix=[]
    for i in range(4):
        nucMatrix.append(nucLine(i,nucs))
    return nucMatrix    
# Again, run 100 simulations of 100 steps and look at the ending states. Then
# try changing the transition matrix.

 
def changeLine(matrix): 
    changeMatrix=[] 
    for i in range(0,4):
        if i==0:
            change=matrix[0][0]
        else:    
            change+=matrix[0][i-1]
        changeMatrix.append(change)
    return changeMatrix   

def changeMat(matrix):
    nrow=4
    changeMatrix=[]
    if nrow==0:
        changeLine(matrix)
    else:
        while nrow>0:
            x=changeLine(matrix)
            changeMatrix.append(x)
            nrow=nrow-1
    return changeMatrix        
    
            
        
def chooser(row,matrix,nucs):
    def changeLine(matrix): 
        changeMatrix=[] 
        for i in range(0,4):
            if i==0:
                change=matrix[0][0]
            else:    
                change+=matrix[0][i-1]
            changeMatrix.append(change)
        return changeMatrix   
    def changeMat(matrix):
        nrow=4
        changeMatrix=[]
        if nrow==0:
            changeLine(matrix)
        else:
            while nrow>0:
                x=changeLine(matrix)
                changeMatrix.append(x)
                nrow=nrow-1
        return changeMatrix  
    changeMatrix=changeMat(nucMatrix)    
    nucleotide=""
    row=row
    seed=scipy.random.random(1)
    if seed<=changeMatrix[row][0]:
        nucleotide=nucs[0]
    elif seed<=changeMatrix[row][1]:
        nucleotide=nucs[1]  
    elif seed<=changeMatrix[row][2]:
        nucleotide=nucs[2] 
    elif seed<=changeMatrix[row][3]:
        nucleotide=nucs[3]     
    return nucleotide 
 
        
chooser(0,nucMatrix,nucs)        

def nucMarkovChain(matrix,length):
    def chooser(row,matrix,nucs):
        def changeLine(matrix): 
            changeMatrix=[] 
            for i in range(0,4):
                if i==0:
                    change=matrix[0][0]
                else:    
                    change+=matrix[0][i-1]
                changeMatrix.append(change)
            return changeMatrix   
        def changeMat(matrix):
            nrow=4
            changeMatrix=[]
            if nrow==0:
                changeLine(matrix)
            else:
                while nrow>0:
                    x=changeLine(matrix)
                    changeMatrix.append(x)
                    nrow=nrow-1
            return changeMatrix  
        changeMatrix=changeMat(nucMatrix)    
        nucleotide=""
        row=row
        seed=scipy.random.random(1)
        if seed<=changeMatrix[row][0]:
            nucleotide=nucs[0]
        elif seed<=changeMatrix[row][1]:
            nucleotide=nucs[1]  
        elif seed<=changeMatrix[row][2]:
            nucleotide=nucs[2] 
        elif seed<=changeMatrix[row][3]:
            nucleotide=nucs[3]     
        return nucleotide 
    nucs=("A","C","G","T")     
    def nucLine(row,nucs): #make a row of nucleotide transitions that line up with the transition matrix
        nucLine=[]
        for i in range(4):
            row=row
            g=nucs[row]
            f=nucs[i]
            nucLine.append((g,f))
        return nucLine   
    def nucleotideMatrix(nucs): #iterate the lines into a matrix
        nucMatrix=[]
        for i in range(4):
            nucMatrix.append(nucLine(i,nucs))
        return nucMatrix  
    nucleotideMatrix=nucleotideMatrix(nucs) #make the matrix
    nucleotide=chooser(0,matrix,nucs) #seed the Markov chain with the first nucleotide  
    start=chooser(0,matrix,nucs)
    chain=[start]
    seed=scipy.random.random(1)
    if length==1:
        return chain
    else:
        if nucleotide=="A":
            row=0
        elif nucleotide=="C":
            row=1
        elif nucleotide=="G":
            row=2
        elif nucleotide=="T":
            row=3
        for state in markovChain(matrix,(length-1)):
            nucleotide=chooser(row,matrix,nucs)
            chain.append(nucleotide)   
        return chain
        
        
nucMarkovChain(nucMatrix,30)  
